/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/
using System.Collections;
using System.Text;
using LLVMSharp.Compiler.Ast;
using LLVMSharp.Compiler.CocoR;
using System;
using System.Diagnostics;



public class Parser :IParser {
	public const int _EOF = 0;
	public const int _ident = 1;
	public const int _integerConstant = 2;
	public const int _realConstant = 3;
	public const int _characterConstant = 4;
	public const int _stringConstant = 5;
	public const int _base = 6;
	public const int _bool = 7;
	public const int _break = 8;
	public const int _case = 9;
	public const int _char = 10;
	public const int _class = 11;
	public const int _const = 12;
	public const int _continue = 13;
	public const int _do = 14;
	public const int _else = 15;
	public const int _enum = 16;
	public const int _explicit = 17;
	public const int _extern = 18;
	public const int _false = 19;
	public const int _float = 20;
	public const int _for = 21;
	public const int _if = 22;
	public const int _implicit = 23;
	public const int _int = 24;
	public const int _internal = 25;
	public const int _namespace = 26;
	public const int _new = 27;
	public const int _null = 28;
	public const int _object = 29;
	public const int _operator = 30;
	public const int _override = 31;
	public const int _private = 32;
	public const int _protected = 33;
	public const int _public = 34;
	public const int _return = 35;
	public const int _sealed = 36;
	public const int _sizeof = 37;
	public const int _static = 38;
	public const int _string = 39;
	public const int _struct = 40;
	public const int _this = 41;
	public const int _true = 42;
	public const int _typeof = 43;
	public const int _usingKW = 44;
	public const int _virtual = 45;
	public const int _void = 46;
	public const int _while = 47;
	public const int _and = 48;
	public const int _assignment = 49;
	public const int _colon = 50;
	public const int _comma = 51;
	public const int _decrement = 52;
	public const int _divide = 53;
	public const int _dot = 54;
	public const int _conditionalequality = 55;
	public const int _greater = 56;
	public const int _greaterorequals = 57;
	public const int _increment = 58;
	public const int _leftbrace = 59;
	public const int _leftbrack = 60;
	public const int _leftpar = 61;
	public const int _lessthan = 62;
	public const int _lessoreqals = 63;
	public const int _minus = 64;
	public const int _notequals = 65;
	public const int _not = 66;
	public const int _plus = 67;
	public const int _rightbrace = 68;
	public const int _rightbrack = 69;
	public const int _rightpar = 70;
	public const int _semicolon = 71;
	public const int _times = 72;
	public const int maxT = 82;

	const bool T = true;
	const bool x = false;
	const int minErrDist = 2;
	
	public Scanner scanner;
	public Errors  errors;

	public Token t;    // last recognized token
	public Token la;   // lookahead token
	int errDist = minErrDist;

public AstSourceFile RootNode=null;

// Place your custom functions or variables here.
// The contents will be placed in your parser class

Token Peek(int n)
{
    scanner.ResetPeek();
    Token x = la;
    while (n > 0)
    {
        x = scanner.Peek();
        n--;
    }
    return x;
}

const int maxTerminals=160;//set size
static BitArray NewSet(params int[] values)
{
    BitArray a=new BitArray(maxTerminals);
    foreach(int x in values)
        a[x]=true;
    return a;
}

static BitArray
    unaryHead   = NewSet(_plus,_minus,_not,_times,_increment,_decrement),
	typeKW       = NewSet(_char, _bool, _object, _string, _int, _float),
	castFollower = NewSet(_not, _leftpar, _ident,
	               /* literals */
	               _integerConstant, _realConstant, _characterConstant, _stringConstant,
	               /* any keyword expect as and is */
	               _base, _bool, _break, _case,
				   _char, _class, _const, _continue, 
				   _do, _else, _enum, _explicit,
				   _extern, _false, _float, _for,
				   _if, _implicit, _int,
				   _namespace, _new, _null, _object, _operator,
				   _override, _private, _protected, _public,
				   _return, _sealed, _sizeof,
				   _static, _string, _struct, _this,
				   _true, _typeof,
                   _usingKW, _virtual, _void, _while
	               );

bool IsFunction()
{
  return Peek(1).kind==_leftpar;
}

bool IsField()
{
   int peek = Peek(1).kind;
	return la.kind == _ident && 
	       (peek == _comma || peek == _assignment || peek == _semicolon);
	       /*int x, int x =, int x; */
}

bool IsGetAccessor()
{
    return la.val == "get" ;
}
bool IsDimensions(ref Token pt){
	while(true){
		if(pt.kind==_leftbrack){
			do pt=scanner.Peek();
			while(pt.kind==_comma);
			if(pt.kind!=_rightbrack) return false;
		}else if(pt.kind!=_times) break;
		pt=scanner.Peek();
	}
	return true;
}

public bool IsDims(){
	int peek=Peek(1).kind;
	return la.kind == _leftbrack && peek == _rightbrack;
}

bool IsLocalVarDecl()
{
    string ignore;
	Token pt=la;
	scanner.ResetPeek();
	if(la.kind==_char || la.kind==_bool || la.kind==_object || la.kind==_string || la.kind==_int || la.kind==_float){
		pt=scanner.Peek();
	}else if(la.kind==_ident && !IsQualident(ref pt,out ignore)){
		return false;
	}
    return IsDimensions(ref pt) && pt.kind==_ident ;
}

bool IsQualident (ref Token pt, out string qualident) {
	qualident = "";
	if (pt.kind == _ident) {
		qualident = pt.val;
		pt = scanner.Peek();
		while (pt.kind == _dot) {
			pt = scanner.Peek();
			if (pt.kind != _ident) return false;
			qualident += "." + pt.val;
			pt = scanner.Peek();
		}
		return true;
	} else return false;
}

bool IsTypeCast()
{
    if(la.kind != _leftpar)
        return false;
   	if (IsSimpleTypeCast()) return true;
	return GuessTypeCast();
}

// "(" typeKW ")"
bool IsSimpleTypeCast () {
	scanner.ResetPeek();
	Token pt1 = scanner.Peek();
	Token pt = scanner.Peek();
	return typeKW[pt1.kind] && pt.kind == _rightpar;
}

// "(" Type ")" castFollower
bool GuessTypeCast () {
	string id;
	scanner.ResetPeek();
	Token pt = scanner.Peek();
	if (typeKW[pt.kind]) {
		pt = scanner.Peek();
	} else if (pt.kind==_void) {
		pt = scanner.Peek();
		if (pt.kind != _times) {
			return false;
		}
		pt = scanner.Peek();
	} else if(IsQualident(ref pt, out id)) {
		// nothing to do
	} else {
		return false;
	}
	if (IsDimensions(ref pt) && pt.kind==_rightpar)
	{
		pt = scanner.Peek(); // check successor
		return castFollower[pt.kind];
	} else {
		return false;
	}
}




	public Parser(Scanner scanner) {
		this.scanner = scanner;
		errors = new Errors();
	}

	void SynErr (int n) {
		if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n , scanner.FileName);
		errDist = 0;
	}

	public void SemErr (string msg) {
		if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg);
		errDist = 0;
	}
	
	void Get () {
		for (;;) {
			t = la;
			la = scanner.Scan();
			if (la.kind <= maxT) { ++errDist; break; }

			la = t;
		}
	}
	
	void Expect (int n) {
		if (la.kind==n) Get(); else { SynErr(n); }
	}
	
	bool StartOf (int s) {
		return set[s, la.kind];
	}
	
	void ExpectWeak (int n, int follow) {
		if (la.kind == n) Get();
		else {
			SynErr(n);
			while (!StartOf(follow)) Get();
		}
	}


	bool WeakSeparator(int n, int syFol, int repFol) {
		int kind = la.kind;
		if (kind == n) {Get(); return true;}
		else if (StartOf(repFol)) {return false;}
		else {
			SynErr(n);
			while (!(set[syFol, kind] || set[repFol, kind] || set[0, kind])) {
				Get();
				kind = la.kind;
			}
			return StartOf(syFol);
		}
	}

	
	void LLVMSharp() {
		RootNode=new AstSourceFile(this);	
		RootNode.AstUsingDeclarativeCollection=new AstUsingDeclarativeCollection();
		
		while (la.kind == 44) {
			AstUsingDeclarative astUsingDeclarative=null;
			UsingDeclaritive(out astUsingDeclarative);
			RootNode.AstUsingDeclarativeCollection.Add(astUsingDeclarative); 
		}
		while (StartOf(1)) {
			IAstNamespaceMember astNamespaceMember=null;
			NamespaceMember(out astNamespaceMember);
			if(astNamespaceMember is AstNamespaceBlock)
			    RootNode.AstNamespaceBlockCollection.Add(astNamespaceMember);
			else if(astNamespaceMember is AstType)
			    RootNode.AstTypeCollection.Add(astNamespaceMember);
			
		}
	}

	void UsingDeclaritive(out AstUsingDeclarative astUsingDeclarative) {
		astUsingDeclarative=new AstUsingDeclarative(this); 
		Expect(44);
		Qualident(out astUsingDeclarative.Namespace);
		Expect(71);
	}

	void NamespaceMember(out IAstNamespaceMember astNamespaceMember) {
		astNamespaceMember=null; 
		if (la.kind == 26) {
			AstNamespaceBlock astNamespaceBlock=new AstNamespaceBlock(this); 
			Get();
			Qualident(out astNamespaceBlock.Namespace);
			Expect(59);
			IAstNamespaceMember astNamespaceMember2=null;  
			while (StartOf(1)) {
				NamespaceMember(out astNamespaceMember2);
				if(astNamespaceMember2 is AstNamespaceBlock)
				astNamespaceBlock.AstNamespaceBlockCollection.Add(astNamespaceMember2);
				else if(astNamespaceMember2 is AstType)
				astNamespaceBlock.AstTypeCollection.Add(astNamespaceMember2);
				
			}
			Expect(68);
			if (la.kind == 71) {
				Get();
			}
			astNamespaceMember=astNamespaceBlock;
		} else if (StartOf(2)) {
			int l=la.line,c=la.col; 
			                        AstTypeModifierCollection astTypeModifierCollection=new AstTypeModifierCollection();
			                    
			while (StartOf(3)) {
				AstTypeModifier astTypeModifier=null; 
				TypeModifiers(out astTypeModifier);
				astTypeModifierCollection.Add(astTypeModifier); 
			}
			AstType astType=null; 
			TypeDecl(out astType);
			if(astType==null && la.val=="extern"){ /* bug fix when put extern enum */
			errors.errorList.Add(new ErrorInfo(ErrorType.SyntaxError,
			"The modifer 'extern' is not valid for this item.",
			la.line,la.col,scanner.FileName));
			}else{
			if(astType!=null){
			astType.LineNumber =l;
			 astType.ColumnNumber =c; 
			 astType.AstTypeModifierCollection=astTypeModifierCollection;
			astNamespaceMember=astType;
			}
			}
			
		} else SynErr(83);
	}

	void Qualident(out string qualident) {
		StringBuilder sb=new StringBuilder(); 
		Expect(1);
		sb.Append(t.val); 
		while (la.kind == 54) {
			Get();
			Expect(1);
			sb.Append(".");sb.Append(t.val); 
		}
		qualident=sb.ToString(); 
	}

	void TypeModifiers(out AstTypeModifier astTypeModifier) {
		astTypeModifier=null; 
		if (la.kind == 34) {
			Get();
			astTypeModifier=new AstPublicTypeModifier(this,false); 
		} else if (la.kind == 33) {
			Get();
			astTypeModifier=new AstProtectedTypeModifier(this,false); 
		} else if (la.kind == 32) {
			Get();
			astTypeModifier=new AstPrivateTypeModifier(this,false); 
		} else if (la.kind == 36) {
			Get();
			astTypeModifier=new AstSealedTypeModifier(this,false); 
		} else SynErr(84);
	}

	void TypeDecl(out AstType astType) {
		astType=null; 
		if (la.kind == 11 || la.kind == 40) {
			if (la.kind == 11) {
				AstClass astClass=new AstClass(this); 
				Get();
				Expect(1);
				astClass.Name=t.val; 
				if (la.kind == 50) {
					ClassBase(out astClass.AstParentClass);
				}
				ClassBody(ref astClass);
				if (la.kind == 71) {
					Get();
				}
				astType=astClass; 
			} else {
				AstStruct astStruct=new AstStruct(this); 
				Get();
				Expect(1);
				astStruct.Name=t.val; 
				StructBody(ref astStruct);
				if (la.kind == 71) {
					Get();
				}
				astType=astStruct; 
			}
		} else if (la.kind == 16) {
			AstEnum astEnum=new AstEnum(this); 
			Get();
			Expect(1);
			astEnum.Name=t.val; 
			if (la.kind == 50) {
				Get();
				Expect(24);
				astEnum.AstEnumType=new AstEnumType(this,false); 
				  astEnum.AstEnumType.Name="int";
				
			}
			EnumBody(out astEnum.AstEnumMemberCollection);
			if (la.kind == 71) {
				Get();
			}
			astType=astEnum; 
		} else SynErr(85);
	}

	void ClassBase(out AstParentClass astParentClass) {
		astParentClass=null; string parentClass=""; 
		Expect(50);
		ClassType(out parentClass);
		astParentClass=new AstParentClass(this,false);
		astParentClass.Name=parentClass;
		
	}

	void ClassBody(ref AstClass astClass) {
		IObjectMember objectMember=null; 
		Expect(59);
		while (StartOf(4)) {
			AstMemberModifierCollection astMemberModifierCollection=new AstMemberModifierCollection(); 
			while (StartOf(5)) {
				AstMemberModifier astMemberModifier=null;  
				MemberModifier(out astMemberModifier);
				astMemberModifierCollection.Add(astMemberModifier);  
			}
			ClassMember(out objectMember);
			if(objectMember!=null){
			objectMember.AstMemberModifierCollection=astMemberModifierCollection; 
			if(objectMember is AstType)
			astClass.AstTypeCollection.Add(objectMember);
			else if(objectMember is AstConstructor)
			astClass.AstConstructorCollection.Add(objectMember);
			else if(objectMember is AstMethod)
			astClass.AstMethodCollection.Add(objectMember);
			else if(objectMember is AstAccessor)
			astClass.AstAccessorCollection.Add(objectMember);
			else if(objectMember is AstTypeConverter)
			astClass.AstTypeConverterCollection.Add(objectMember);
			else if(objectMember is AstOperatorOverload)
			astClass.AstOperatorOverloadCollection.Add(objectMember);
			
			// if there were membermodifiers, then then update the line and col
			// to the first MemberModifier
			if((objectMember is AstFieldCollection)){ // coz AstFieldCollection is not a AstNode.
			AstFieldCollection fields=(AstFieldCollection)objectMember;
			foreach(AstField field in fields){ // start copying the membermodifers to all the fields and also copy to AstType
			field.AstMemberModifierCollection=astMemberModifierCollection;
			astClass.AstFieldCollection.Add(field);
			}
			}else{
			AstNode astNode=(AstNode)objectMember;
			if(objectMember.AstMemberModifierCollection.Count>0){
			AstMemberModifier temp=(AstMemberModifier)objectMember.AstMemberModifierCollection[0];
			astNode.LineNumber = temp.LineNumber;
			astNode.ColumnNumber = temp.ColumnNumber;
			}
			}
			}
			
		}
		Expect(68);
	}

	void StructBody(ref AstStruct astStruct) {
		IObjectMember objectMember=null;  
		Expect(59);
		while (StartOf(4)) {
			AstMemberModifierCollection astMemberModifierCollection=new AstMemberModifierCollection(); 
			while (StartOf(5)) {
				AstMemberModifier astMemberModifier=null;  
				MemberModifier(out astMemberModifier);
				astMemberModifierCollection.Add(astMemberModifier);  
			}
			StructMember(out objectMember);
			if(objectMember!=null){
			objectMember.AstMemberModifierCollection=astMemberModifierCollection; 
			if(objectMember is AstType)
			astStruct.AstTypeCollection.Add(objectMember);
			else if(objectMember is AstConstructor)
			astStruct.AstConstructorCollection.Add(objectMember);
			else if(objectMember is AstMethod)
			astStruct.AstMethodCollection.Add(objectMember);
			else if(objectMember is AstAccessor)
			astStruct.AstAccessorCollection.Add(objectMember);
			else if(objectMember is AstTypeConverter)
			astStruct.AstTypeConverterCollection.Add(objectMember);
			else if(objectMember is AstOperatorOverload)
			astStruct.AstOperatorOverloadCollection.Add(objectMember);
			
			// if there were membermodifiers, then then update the line and col
			// to the first MemberModifier
			if(objectMember is AstFieldCollection){ // coz AstFieldCollection is not a AstNode.
			AstFieldCollection fields=(AstFieldCollection)objectMember;
			foreach(AstField field in fields){ // start copying the membermodifers to all the fields and also copy to AstType
			field.AstMemberModifierCollection=astMemberModifierCollection;
			astStruct.AstFieldCollection.Add(field);
			}
			}else{
			AstNode astNode=(AstNode)objectMember;
			if(objectMember.AstMemberModifierCollection.Count>0){
			AstMemberModifier temp=(AstMemberModifier)objectMember.AstMemberModifierCollection[0];
			astNode.LineNumber = temp.LineNumber;
			astNode.ColumnNumber = temp.ColumnNumber;
			}
			}
			}
			
		}
		Expect(68);
	}

	void EnumBody(out AstEnumMemberCollection astEnumMemberCollection) {
		astEnumMemberCollection=new AstEnumMemberCollection(); 
		Expect(59);
		AstEnumMember astEnumMember=null;
		EnumMember(out astEnumMember);
		astEnumMemberCollection.Add(astEnumMember); 
		while (la.kind == 51) {
			Get();
			AstEnumMember astEnumMember2=null;
			EnumMember(out astEnumMember2);
			astEnumMemberCollection.Add(astEnumMember2); 
		}
		Expect(68);
	}

	void ClassType(out string classType) {
		classType="";
		if (la.kind == 1) {
			Qualident(out classType);
		} else if (la.kind == 29 || la.kind == 39) {
			if (la.kind == 29) {
				Get();
			} else {
				Get();
			}
			classType=t.val; 
		} else SynErr(86);
	}

	void MemberModifier(out AstMemberModifier astMemberModifier) {
		astMemberModifier=null; 
		switch (la.kind) {
		case 31: {
			Get();
			astMemberModifier=new AstOverrideMemberModifier(this,false); 
			break;
		}
		case 34: {
			Get();
			astMemberModifier=new AstPublicMemberModifier(this,false); 
			break;
		}
		case 32: {
			Get();
			astMemberModifier=new AstPrivateMemberModifier(this,false); 
			break;
		}
		case 33: {
			Get();
			astMemberModifier=new AstProtectedMemberModifier(this,false); 
			break;
		}
		case 36: {
			Get();
			astMemberModifier=new AstSealedMemberModifier(this,false); 
			break;
		}
		case 38: {
			Get();
			astMemberModifier=new AstStaticMemberModifier(this,false); 
			break;
		}
		case 18: {
			Get();
			astMemberModifier=new AstExternMemberModifier(this,false); 
			break;
		}
		case 45: {
			Get();
			astMemberModifier=new AstVirtualMemberModifier(this,false); 
			break;
		}
		default: SynErr(87); break;
		}
	}

	void ClassMember(out IObjectMember objectMember) {
		objectMember=null; 
		StructMember(out objectMember);
	}

	void StructMember(out IObjectMember objectMember) {
		objectMember=null; 
		if (la.kind == 12) {
			AstField astField=new AstField(this); AstFieldCollection astFieldCollection=new AstFieldCollection(); 
			Get();
			astField.IsConstant=true; string type=""; 
			Type(out type,out astField.IsArray);
			astField.Type=type; 
			Expect(1);
			astField.Name=t.val; 
			astField.LineNumber=t.line;
			astField.ColumnNumber=t.col;
			
			Expect(49);
			IAstExpression astExpression=null; 
			Expr(out astExpression);
			astField.Initialization=astExpression; astFieldCollection.Add(astField); 
			while (la.kind == 51) {
				Get();
				AstField astField2=new AstField(this); astField2.IsConstant=true; 
				Expect(1);
				astField2.Name=t.val; astField2.Type=type; 
				astField2.LineNumber=t.line;
				astField2.ColumnNumber=t.col;
				
				Expect(49);
				IAstExpression astExpression2=null; 
				Expr(out astExpression2);
				astField2.Initialization=astExpression2; 
				astFieldCollection.Add(astField2); 
			}
			Expect(71);
			objectMember=astFieldCollection; 
		} else if (IsFunction()) {
			Expect(1);
			AstConstructor astConstructor=new AstConstructor(this,false);
			astConstructor.Name=t.val;
			
			Expect(61);
			if (StartOf(6)) {
				FormalParams(ref astConstructor.Parameters);
			}
			Expect(70);
			if (la.kind == 50) {
				ConstructorCall(out astConstructor.AstConstructorCall);
			}
			if (la.kind == 59) {
				Block(out astConstructor.AstBlock);
			} else if (la.kind == 71) {
				Get();
				astConstructor.AstBlock=null;
			} else SynErr(88);
			objectMember=astConstructor;
		} else if (la.kind == 46) {
			AstMethod astMethod=new AstMethod(this); 
			Get();
			astMethod.ReturnType="void" ; 
			Expect(1);
			astMethod.Name=t.val; 
			Expect(61);
			if (StartOf(6)) {
				FormalParams(ref astMethod.Parameters);
			}
			Expect(70);
			if (la.kind == 59) {
				Block(out astMethod.AstBlock);
			} else if (la.kind == 71) {
				Get();
			} else SynErr(89);
			objectMember=astMethod; 
		} else if (la.kind == 17 || la.kind == 23) {
			AstTypeConverter astTypeConverter=null; 
			if (la.kind == 23) {
				Get();
				astTypeConverter=new AstImplicitTypeConverter(this,false); 
			} else {
				Get();
				astTypeConverter=new AstExplicitTypeConverter(this,false); 
			}
			Expect(30);
			Type(out astTypeConverter.ReturnType,out astTypeConverter.IsArray);
			Expect(61);
			astTypeConverter.AstParameter=new AstParameter(this);
			astTypeConverter.AstParameter.ParameterType=new AstPassByValueParameterType(this);
			
			Type(out astTypeConverter.AstParameter.Type,out astTypeConverter.AstParameter.IsArray);
			Expect(1);
			astTypeConverter.AstParameter.Name=t.val; 
			Expect(70);
			if (la.kind == 59) {
				Block(out astTypeConverter.AstBlock);
			} else if (la.kind == 71) {
				Get();
			} else SynErr(90);
			objectMember=astTypeConverter; 
		} else if (la.kind == 11 || la.kind == 16 || la.kind == 40) {
			AstType astType=null; 
			TypeDecl(out astType);
			objectMember=astType; 
		} else if (StartOf(7)) {
			string fieldOrMethodType=""; bool isArray; 
			Type(out fieldOrMethodType,out isArray);
			if (la.kind == 30) {
				AstOperatorOverload astOperatorOverload=new AstOperatorOverload(this); 
				Get();
				OverloadableOp(ref astOperatorOverload.OverloadableOperand);
				astOperatorOverload.ReturnType = fieldOrMethodType; astOperatorOverload.IsArray=isArray; 
				Expect(61);
				AstParameter astParameter1=new AstParameter(this); astParameter1.ParameterType=new AstPassByValueParameterType(this); 
				Type(out astParameter1.Type,out astParameter1.IsArray);
				Expect(1);
				astParameter1.Name=t.val; astOperatorOverload.AstParameter1=astParameter1; 
				if (la.kind == 51) {
					Get();
					AstParameter astParameter2=new AstParameter(this); astParameter2.ParameterType=new AstPassByValueParameterType(this); 
					Type(out astParameter2.Type,out astParameter2.IsArray);
					Expect(1);
					astParameter2.Name=t.val; astOperatorOverload.AstParameter2=astParameter2; 
				}
				Expect(70);
				if (la.kind == 59) {
					Block(out astOperatorOverload.AstBlock);
				} else if (la.kind == 71) {
					Get();
				} else SynErr(91);
				objectMember=astOperatorOverload; 
			} else if (IsField()) {
				AstField astField=null; AstFieldCollection astFieldCollection=new AstFieldCollection(); 
				Field(out astField);
				astField.Type=fieldOrMethodType; astFieldCollection.Add(astField); 
				while (la.kind == 51) {
					AstField astField2=null; 
					Get();
					Field(out astField2);
					astField2.Type=fieldOrMethodType; astFieldCollection.Add(astField2); 
				}
				Expect(71);
				objectMember=astFieldCollection; 
			} else if (la.kind == 1) {
				Get();
				string name=t.val; 
				if (la.kind == 61) {
					AstMethod astMethod=new AstMethod(this,false); 
					astMethod.Name=name; astMethod.ReturnType=fieldOrMethodType; 
					Get();
					if (StartOf(6)) {
						FormalParams(ref astMethod.Parameters);
					}
					Expect(70);
					if (la.kind == 59) {
						Block(out astMethod.AstBlock);
					} else if (la.kind == 71) {
						Get();
					} else SynErr(92);
					objectMember=astMethod; 
				} else if (la.kind == 59) {
					string accessorName=name; 
					Get();
					AstAccessor astAccessor=null; 
					Accessors(out astAccessor);
					astAccessor.Name=accessorName; astAccessor.ReturnType=fieldOrMethodType; 
					Expect(68);
					objectMember=astAccessor; 
				} else SynErr(93);
			} else SynErr(94);
		} else SynErr(95);
	}

	void Type(out string type,out bool isArray) {
		type=""; isArray=false; 
		if (StartOf(8)) {
			SimpleType(out type);
		} else if (la.kind == 1 || la.kind == 29 || la.kind == 39) {
			ClassType(out type);
		} else SynErr(96);
		if (IsDims()) {
			if (la.kind == 60) {
				Get();
				isArray=true; 
				Expect(69);
			}
		} else if (StartOf(9)) {
		} else SynErr(97);
	}

	void Expr(out IAstExpression astExpression) {
		astExpression=null; IAstExpression astExpression2=null; AstAssignmentExpression astAssignmentExpression=null;
		Unary(out astExpression);
		if (StartOf(10)) {
			OrExpr(ref astExpression);
		} else if (StartOf(11)) {
			AssignOp(out astAssignmentExpression);
			Expr(out astExpression2);
			if(astAssignmentExpression!=null){
			astAssignmentExpression.LValue=astExpression;
			astAssignmentExpression.RValue=astExpression2;
			astExpression=astAssignmentExpression;
			return;
			}
			
		} else SynErr(98);
		if(astExpression2!=null && astExpression2 is AstBinaryExpression){
		AstBinaryExpression astBinaryExpression=(AstBinaryExpression)astExpression2;
		astBinaryExpression.LeftOperand=astExpression;
		astExpression=astBinaryExpression;
		 }
		
	}

	void FormalParams(ref AstParameterCollection parameters) {
		AstParameter parameter=null; 
		Par(out parameter);
		parameters.Add(parameter); 
		if (la.kind == 51) {
			Get();
			FormalParams(ref parameters);
		}
	}

	void ConstructorCall(out AstConstructorCall astConstructorCall) {
		astConstructorCall=null; 
		Expect(50);
		if (la.kind == 6) {
			Get();
			astConstructorCall=new AstBaseConstructorCall(this); 
		} else if (la.kind == 41) {
			Get();
			astConstructorCall=new AstThisConstructorCall(this); 
		} else SynErr(99);
		Expect(61);
		if (StartOf(12)) {
			AstArgument astArgument1=null; 
			Argument(out astArgument1);
			astConstructorCall.AstArgumentCollection.Add(astArgument1); 
			while (la.kind == 51) {
				Get();
				AstArgument astArgument2=null; 
				Argument(out astArgument2);
				astConstructorCall.AstArgumentCollection.Add(astArgument2); 
			}
		}
		Expect(70);
	}

	void Block(out AstBlock astBlock) {
		astBlock=new AstBlock(this); 
		Expect(59);
		while (StartOf(13)) {
			Statement(ref astBlock.AstStatementCollection);
		}
		Expect(68);
	}

	void OverloadableOp(ref OverloadableOperand overloadableOperand) {
		switch (la.kind) {
		case 67: {
			Get();
			overloadableOperand=OverloadableOperand.Plus; 
			break;
		}
		case 64: {
			Get();
			overloadableOperand=OverloadableOperand.Minus; 
			break;
		}
		case 66: {
			Get();
			overloadableOperand=OverloadableOperand.Not; 
			break;
		}
		case 58: {
			Get();
			overloadableOperand=OverloadableOperand.Increment; 
			break;
		}
		case 52: {
			Get();
			overloadableOperand=OverloadableOperand.Decrement; 
			break;
		}
		case 42: {
			Get();
			overloadableOperand=OverloadableOperand.True; 
			break;
		}
		case 19: {
			Get();
			overloadableOperand=OverloadableOperand.False; 
			break;
		}
		case 72: {
			Get();
			overloadableOperand=OverloadableOperand.Multiplication; 
			break;
		}
		case 53: {
			Get();
			overloadableOperand=OverloadableOperand.Division; 
			break;
		}
		case 55: {
			Get();
			overloadableOperand=OverloadableOperand.Equality; 
			break;
		}
		case 65: {
			Get();
			overloadableOperand=OverloadableOperand.NotEqual; 
			break;
		}
		case 56: {
			Get();
			overloadableOperand=OverloadableOperand.GreaterThan; 
			break;
		}
		case 62: {
			Get();
			overloadableOperand=OverloadableOperand.LessThan; 
			break;
		}
		case 57: {
			Get();
			overloadableOperand=OverloadableOperand.GreaterThanEqual; 
			break;
		}
		case 63: {
			Get();
			overloadableOperand=OverloadableOperand.LessThanEqual; 
			break;
		}
		default: SynErr(100); break;
		}
	}

	void Field(out AstField astField) {
		astField=new AstField(this); 
		Expect(1);
		astField.Name=t.val; 
		if (la.kind == 49) {
			Get();
			Init(out astField.Initialization);
		}
	}

	void Accessors(out AstAccessor astAccessor) {
		astAccessor=new AstAccessor(this);  
		if (IsGetAccessor()) {
			GetAccessor(ref astAccessor);
			if (la.kind == 1) {
				SetAccessor(ref astAccessor);
			}
		} else if (la.kind == 1) {
			SetAccessor(ref astAccessor);
			if (la.kind == 1) {
				GetAccessor(ref astAccessor);
			}
		} else SynErr(101);
	}

	void IntType(out string intType) {
		if (la.kind == 24) {
			Get();
		} else if (la.kind == 10) {
			Get();
		} else SynErr(102);
		intType=t.val; 
	}

	void EnumMember(out AstEnumMember astEnumMember) {
		Expect(1);
		astEnumMember=new AstEnumMember(this,false);
		astEnumMember.Name=t.val; 
	}

	void SimpleType(out string simpleType) {
		simpleType=""; 
		if (la.kind == 10 || la.kind == 24) {
			IntType(out simpleType);
		} else if (la.kind == 7 || la.kind == 20) {
			if (la.kind == 7) {
				Get();
			} else {
				Get();
			}
			simpleType=t.val; 
		} else SynErr(103);
	}

	void Argument(out AstArgument astArgument) {
		astArgument=new AstArgument(this,false); 
		Expr(out astArgument.AstExpression);
	}

	void Statement(ref AstStatementCollection astStatementCollection) {
		if (la.kind == 12) {
			AstLocalVariableDeclaration astLocalVariableDeclaration=new AstLocalVariableDeclaration(this); 
			Get();
			astLocalVariableDeclaration.IsConstant=true; string type=""; bool isArray; 
			Type(out type,out isArray);
			astLocalVariableDeclaration.Type=type;astLocalVariableDeclaration.IsArray=isArray; 
			Expect(1);
			astLocalVariableDeclaration.Name=t.val; astLocalVariableDeclaration.LineNumber=t.line; astLocalVariableDeclaration.ColumnNumber=t.col;  
			Expect(49);
			astStatementCollection.Add(astLocalVariableDeclaration); 
			Expr(out astLocalVariableDeclaration.Initialization);
			while (la.kind == 51) {
				Get();
				AstLocalVariableDeclaration astLocalVariableDeclaration2=new AstLocalVariableDeclaration(this); 
				Expect(1);
				astLocalVariableDeclaration2.Name=t.val; astLocalVariableDeclaration2.Type=type; 
				Expect(49);
				Expr(out astLocalVariableDeclaration2.Initialization);
				astStatementCollection.Add(astLocalVariableDeclaration2); 
			}
		} else if (IsLocalVarDecl()) {
			LocalVarDecl(ref astStatementCollection);
			Expect(71);
		} else if (StartOf(14)) {
			AstStatement astStatement=null; 
			EmbeddedStatement(out astStatement);
			astStatementCollection.Add(astStatement); 
		} else SynErr(104);
	}

	void LocalVarDecl(ref AstStatementCollection astStatementCollection) {
		string type="";bool isArray; 
		Type(out type,out isArray);
		AstLocalVariableDeclaration astLocalVariableDeclaration=null; 
		LocalVar(out astLocalVariableDeclaration);
		astLocalVariableDeclaration.Type=type; astLocalVariableDeclaration.IsArray=isArray; astStatementCollection.Add(astLocalVariableDeclaration); 
		while (la.kind == 51) {
			AstLocalVariableDeclaration astLocalVariableDeclaration2=null; 
			Get();
			LocalVar(out astLocalVariableDeclaration2);
			astLocalVariableDeclaration2.Type=type;astLocalVariableDeclaration2.IsArray=isArray; astStatementCollection.Add(astLocalVariableDeclaration2);  
		}
	}

	void EmbeddedStatement(out AstStatement astStatement) {
		astStatement=null; 
		switch (la.kind) {
		case 59: {
			AstBlock astBlock=null; 
			Block(out astBlock);
			astStatement=astBlock; 
			break;
		}
		case 71: {
			Get();
			break;
		}
		case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 10: case 19: case 20: case 24: case 27: case 28: case 29: case 37: case 39: case 41: case 42: case 43: case 52: case 58: case 61: case 64: case 66: case 67: {
			IAstExpression astExpression=null; 
			StatementExpr(out astExpression);
			Expect(71);
			astStatement=(AstStatement)astExpression; 
			break;
		}
		case 22: {
			AstIfCondition astIfCondition=new AstIfCondition(this); 
			Get();
			Expect(61);
			Expr(out astIfCondition.Condition);
			Expect(70);
			EmbeddedStatement(out astIfCondition.AstStatement);
			if (la.kind == 15) {
				Get();
				EmbeddedStatement(out astIfCondition.AstStatementElse);
			}
			astStatement=astIfCondition; 
			break;
		}
		case 47: {
			AstWhileLoop astWhileLoop=new AstWhileLoop(this); 
			Get();
			Expect(61);
			Expr(out astWhileLoop.Condition);
			Expect(70);
			EmbeddedStatement(out astWhileLoop.AstStatement);
			astStatement=astWhileLoop; 
			break;
		}
		case 14: {
			AstDoLoop astDoLoop=new AstDoLoop(this); 
			Get();
			EmbeddedStatement(out astDoLoop.AstStatement);
			Expect(47);
			Expect(61);
			Expr(out astDoLoop.Condition);
			Expect(70);
			Expect(71);
			astStatement=astDoLoop; 
			break;
		}
		case 21: {
			AstForLoop astForLoop=new AstForLoop(this); 
			Get();
			Expect(61);
			if (StartOf(12)) {
				ForInit(ref astForLoop.Initializers);
			}
			Expect(71);
			if (StartOf(12)) {
				Expr(out astForLoop.Condition);
			}
			Expect(71);
			if (StartOf(12)) {
				ForInc(ref astForLoop.IncrementExpressions);
			}
			Expect(70);
			EmbeddedStatement(out astForLoop.Body);
			astStatement=astForLoop; 
			break;
		}
		case 8: {
			AstBreak astBreak=new AstBreak(this); 
			Get();
			Expect(71);
			astStatement=astBreak; 
			break;
		}
		case 13: {
			AstContinue astContinue=new AstContinue(this); 
			Get();
			Expect(71);
			astStatement=astContinue; 
			break;
		}
		case 35: {
			AstReturn astReturn=new AstReturn(this); 
			Get();
			if (StartOf(12)) {
				Expr(out astReturn.AstExpression);
			}
			Expect(71);
			astStatement=astReturn; 
			break;
		}
		default: SynErr(105); break;
		}
	}

	void LocalVar(out AstLocalVariableDeclaration astLocalVariableDeclaration) {
		astLocalVariableDeclaration=new AstLocalVariableDeclaration(this); 
		Expect(1);
		astLocalVariableDeclaration.Name=t.val; 
		if (la.kind == 49) {
			Get();
			Init(out astLocalVariableDeclaration.Initialization);
		}
	}

	void Init(out IAstExpression astExpression) {
		astExpression=null; 
		if (StartOf(12)) {
			Expr(out astExpression);
		} else if (la.kind == 59) {
			AstArrayInitialization astArrayInitialization=null; 
			ArrayInit(out astArrayInitialization);
			astExpression=astArrayInitialization; 
		} else SynErr(106);
	}

	void StatementExpr(out IAstExpression astExpression) {
		astExpression=null; AstAssignmentExpression astAssignmentExpression=null;
		IAstExpression lvalue=null,rvalue=null; 
		Unary(out lvalue);
		if (StartOf(11)) {
			AssignOp(out astAssignmentExpression);
			AstAssignmentStatement astAssignmentStatement=new AstAssignmentStatement(this); 
			Expr(out rvalue);
			astAssignmentExpression.LValue=lvalue;
			astAssignmentExpression.RValue=rvalue;
			astAssignmentStatement.AstAssignmentExpression=astAssignmentExpression; 
			astExpression=astAssignmentStatement; 
		} else if (la.kind == 51 || la.kind == 70 || la.kind == 71) {
			astExpression=lvalue; 
		} else SynErr(107);
	}

	void ForInit(ref AstStatementCollection astStatementCollection) {
		if (IsLocalVarDecl()) {
			LocalVarDecl(ref astStatementCollection);
		} else if (StartOf(12)) {
			IAstExpression astExpression=null; 
			StatementExpr(out astExpression);
			astStatementCollection.Add(astExpression);  
			while (la.kind == 51) {
				IAstExpression astExpression2=null; 
				Get();
				StatementExpr(out astExpression2);
				astStatementCollection.Add(astExpression2); 
			}
		} else SynErr(108);
	}

	void ForInc(ref AstExpressionCollection astExpressionCollection) {
		IAstExpression astExpression=null; 
		StatementExpr(out astExpression);
		astExpressionCollection.Add(astExpression); 
		while (la.kind == 51) {
			IAstExpression astExpression2=null; 
			Get();
			StatementExpr(out astExpression2);
			astExpressionCollection.Add(astExpression2); 
		}
	}

	void Unary(out IAstExpression astExpression) {
		IAstExpression astExpression1=null,astExpression2=null; string dummy=""; astExpression=null; bool isArray;
		while (unaryHead[la.kind] || IsTypeCast()) {
			switch (la.kind) {
			case 67: {
				Get();
				AstUnaryPlus astUnaryPlus = new AstUnaryPlus(this);
				if(astExpression1==null)
				{ astUnaryPlus.AstExpression = astExpression1;}
				astExpression1=astUnaryPlus;
				
				break;
			}
			case 64: {
				Get();
				AstUnaryMinus astUnaryMinus = new AstUnaryMinus(this);
				if(astExpression1==null)
				{ astUnaryMinus.AstExpression = astExpression1;}
				astExpression1=astUnaryMinus;
				
				break;
			}
			case 66: {
				Get();
				AstNot astNot=new AstNot(this); 
				if(astExpression1!=null)
				astNot.AstExpression=astExpression1;
				astExpression1=astNot;
				
				break;
			}
			case 58: {
				Get();
				AstPreIncrement astPreIncrement=new AstPreIncrement(this); 
				if(astExpression1!=null)
				astPreIncrement.AstExpression=astExpression1;
				astExpression1=astPreIncrement;
				
				break;
			}
			case 52: {
				Get();
				AstPreDecrement astPreDecrement=new AstPreDecrement(this); 
				if(astExpression1!=null)
				astPreDecrement.AstExpression=astExpression1;
				astExpression1=astPreDecrement;
				
				break;
			}
			case 61: {
				Get();
				AstTypeCast astTypeCast = new AstTypeCast(this); 
				Type(out dummy,out isArray);
				if(astExpression!=null)
				{astTypeCast.AstExpression = astExpression1; astTypeCast.IsArray=isArray;}
				astExpression1=astTypeCast;														
				
				Expect(70);
				astTypeCast.VarName=la.val;
				break;
			}
			default: SynErr(109); break;
			}
		}
		Primary(out astExpression2);
		if(astExpression1!=null){
		if(astExpression1 is AstPreDecrement){
		((AstPreDecrement)astExpression1).AstExpression=astExpression2;
		astExpression=astExpression1;
		}else if(astExpression1 is AstPreIncrement){
		((AstPreIncrement)astExpression1).AstExpression=astExpression2;
		astExpression=astExpression1;
		}else if(astExpression1 is AstNot){
		((AstNot)astExpression1).AstExpression=astExpression2;
		astExpression=astExpression1;
		}else if(astExpression1 is AstUnaryMinus){
		((AstUnaryMinus)astExpression1).AstExpression = astExpression2;
		astExpression = astExpression1;
		}else if(astExpression1 is AstUnaryPlus){
		((AstUnaryPlus)astExpression1).AstExpression = astExpression2;
		astExpression = astExpression1;
		}else if(astExpression1 is AstTypeCast){
		((AstTypeCast)astExpression1).AstExpression = astExpression2;
		astExpression = astExpression1;
		}
		}else{
		astExpression=astExpression2;
		}
		
	}

	void AssignOp(out AstAssignmentExpression astAssignmentExpression) {
		astAssignmentExpression=null; 
		if (la.kind == 49) {
			Get();
			astAssignmentExpression=new AstSimpleAssignmentExpression(this,false); 
		} else if (la.kind == 73) {
			Get();
			astAssignmentExpression=new AstAddAssignmentExpression(this,false); 
		} else if (la.kind == 74) {
			Get();
			astAssignmentExpression=new AstSubtractAssignmentExpression(this,false); 
		} else if (la.kind == 75) {
			Get();
			astAssignmentExpression=new AstMultiplyAssignmentExpression(this,false); 
		} else if (la.kind == 76) {
			Get();
			astAssignmentExpression=new AstDivisionAssignmentExpression(this,false); 
		} else SynErr(110);
	}

	void OrExpr(ref IAstExpression astExpression) {
		AndExpr(ref astExpression);
		while (la.kind == 77) {
			AstBinaryExpression astBinaryExpression=null; 
			Get();
			astBinaryExpression=new AstOrExpression(this,false); 
			Unary(out astBinaryExpression.RightOperand);
			astBinaryExpression.LeftOperand=astExpression; 
			AndExpr(ref astBinaryExpression.RightOperand);
			astExpression=astBinaryExpression; 
		}
	}

	void AndExpr(ref IAstExpression astExpression) {
		EqlExpr(ref astExpression);
		while (la.kind == 78) {
			AstBinaryExpression astBinaryExpression=null; 
			Get();
			astBinaryExpression=new AstAndExpression(this,false); 
			Unary(out astBinaryExpression.RightOperand);
			astBinaryExpression.LeftOperand=astExpression; 
			EqlExpr(ref astBinaryExpression.RightOperand);
			astExpression=astBinaryExpression; 
		}
	}

	void EqlExpr(ref IAstExpression astExpression) {
		RelExpr(ref astExpression);
		while (la.kind == 55 || la.kind == 65) {
			AstBinaryExpression astBinaryExpression=null; 
			if (la.kind == 65) {
				Get();
				astBinaryExpression=new AstInequalityExpression(this,false); 
			} else {
				Get();
				astBinaryExpression=new AstEqualityExpression(this,false); 
			}
			astBinaryExpression.LeftOperand=astExpression; 
			Unary(out astBinaryExpression.RightOperand);
			RelExpr(ref astBinaryExpression.RightOperand);
			astExpression=astBinaryExpression; 
		}
	}

	void RelExpr(ref IAstExpression astExpression) {
		AddExpr(ref astExpression);
		while (StartOf(15)) {
			if (StartOf(16)) {
				AstBinaryExpression astBinaryExpression=null; 
				if (la.kind == 62) {
					Get();
					astBinaryExpression=new AstLesserThanExpression(this,false); 
				} else if (la.kind == 56) {
					Get();
					astBinaryExpression=new AstGreaterThanExpression(this,false); 
				} else if (la.kind == 63) {
					Get();
					astBinaryExpression=new AstLesserThanOrEqualExpression(this,false); 
				} else {
					Get();
					astBinaryExpression=new AstGreaterThanOrEqualExpression(this,false); 
				}
				Unary(out astBinaryExpression.RightOperand);
				AddExpr(ref astBinaryExpression.RightOperand);
				astBinaryExpression.LeftOperand=astExpression; astExpression=astBinaryExpression; 
			} else {
				IAstExpression astExpression2=null; string type=""; bool isArray; 
				if (la.kind == 79) {
					Get();
					astExpression2=new AstIsExpression(this,false); 
				} else {
					Get();
					astExpression2=new AstAsExpression(this,false); 
				}
				Type(out type,out isArray);
				if(astExpression2 is AstIsExpression){
				AstIsExpression temp=(AstIsExpression)astExpression2;
				temp.AstExpression=astExpression;
				temp.Type=type;
				temp.IsArray=isArray;
				}else{
				AstAsExpression temp=(AstAsExpression)astExpression2;
				temp.AstExpression=astExpression;
				temp.Type=type;
				temp.IsArray=isArray;
				}
				astExpression=astExpression2;
				
			}
		}
	}

	void AddExpr(ref IAstExpression astExpression) {
		MulExpr(ref astExpression);
		while (la.kind == 64 || la.kind == 67) {
			AstBinaryExpression astBinaryExpression=null; 
			if (la.kind == 67) {
				Get();
				astBinaryExpression=new AstAdditionExpression(this,false);  
			} else {
				Get();
				astBinaryExpression=new AstSubtractionExpression(this,false); 
			}
			astBinaryExpression.LeftOperand=astExpression; 
			Unary(out astBinaryExpression.RightOperand);
			MulExpr(ref astBinaryExpression.RightOperand);
			astExpression=astBinaryExpression; 
		}
	}

	void MulExpr(ref IAstExpression astExpression) {
		while (la.kind == 53 || la.kind == 72) {
			AstBinaryExpression astBinaryExpression=null; 
			if (la.kind == 72) {
				Get();
				astBinaryExpression=new AstMuliplicationExpression(this,false); 
			} else {
				Get();
				astBinaryExpression=new AstDivisionExpression(this,false); 
			}
			Unary(out astBinaryExpression.RightOperand);
			astBinaryExpression.LeftOperand=astExpression;
			 astExpression=astBinaryExpression; 
		}
	}

	void Primary(out IAstExpression astExpression) {
		astExpression=null; 
		switch (la.kind) {
		case 1: {
			Get();
			AstVariableReference astVariableReference=new AstVariableReference(this,false); 
			astVariableReference.VariableName=t.val; astExpression=astVariableReference;
			
			break;
		}
		case 2: case 3: case 4: case 5: case 19: case 28: case 42: {
			Literal(out astExpression);
			break;
		}
		case 61: {
			Get();
			Expr(out astExpression);
			Expect(70);
			break;
		}
		case 7: case 10: case 20: case 24: case 29: case 39: {
			string temp =""; 
			switch (la.kind) {
			case 7: {
				Get();
				break;
			}
			case 10: {
				Get();
				break;
			}
			case 20: {
				Get();
				break;
			}
			case 24: {
				Get();
				break;
			}
			case 29: {
				Get();
				break;
			}
			case 39: {
				Get();
				break;
			}
			}
			temp=t.val; 
			Expect(54);
			Expect(1);
			if(astExpression == null){
			AstMemberReference astMemberReference= new AstMemberReference(this);
			astMemberReference.Type=temp+"."+t.val;
			astExpression =astMemberReference;
			} 
			
			break;
		}
		case 41: {
			Get();
			AstVariableReference astVariableReference = new AstVariableReference(this); 
			astVariableReference.VariableName = "this"; astExpression =astVariableReference;
			break;
		}
		case 6: {
			Get();
			if (la.kind == 54) {
				Get();
				Expect(1);
				if(astExpression == null){
				AstVariableReference astVariableReference= new AstVariableReference(this);
				astVariableReference.VariableName="base"+"."+t.val;
				astExpression =astVariableReference;
				} 
			} else if (la.kind == 60) {
				AstVariableReference astVariableReference = new AstVariableReference(this);
				astVariableReference.VariableName = "base";
				Get();
				Expr(out astVariableReference.Indexer);
				Expect(69);
				astExpression =astVariableReference; 
			} else SynErr(111);
			break;
		}
		case 27: {
			AstNewType astNewType=new AstNewType(this,false); 
			Get();
			Type(out astNewType.Type,out astNewType.IsArray);
			if (la.kind == 61) {
				Get();
				if (StartOf(12)) {
					AstArgument astArgument1=null; 
					Argument(out astArgument1);
					astNewType.AstArgumentCollection.Add(astArgument1);  
					while (la.kind == 51) {
						Get();
						AstArgument astArgument2=null; 
						Argument(out astArgument2);
						astNewType.AstArgumentCollection.Add(astArgument2);  
					}
				}
				Expect(70);
			} else if (la.kind == 60) {
				AstIndexer astIndexer= new AstIndexer(this); 
				Get();
				Expr(out astIndexer.Expression);
				if(astIndexer.Expression is AstIntegerConstant)
				{
				AstIntegerConstant astConstant = new AstIntegerConstant(this);
				astExpression =astConstant;
				}
				
				Expect(69);
				AstArrayInitialization astArrayInitialization=null; astNewType.AstIndexer = astIndexer; 
				if (la.kind == 59) {
					ArrayInit(out astArrayInitialization);
				}
				astNewType.AstArrayInitialization=astArrayInitialization;
				astNewType.AstArgumentCollection=null; 
				astExpression=astNewType; 
			} else if (la.kind == 59) {
				AstArrayInitialization astArrayInitialization=null; 
				ArrayInit(out astArrayInitialization);
				astNewType.AstArrayInitialization=astArrayInitialization;
				astNewType.AstArgumentCollection=null; 
			} else SynErr(112);
			astExpression=astNewType; 
			break;
		}
		case 43: {
			AstTypeOf astTypeOf=new AstTypeOf(this); 
			Get();
			Expect(61);
			Type(out astTypeOf.Type,out astTypeOf.IsArray);
			Expect(70);
			astExpression=astTypeOf; 
			break;
		}
		case 37: {
			AstSizeOf astSizeOf=new AstSizeOf(this); 
			Get();
			Expect(61);
			Type(out astSizeOf.Type,out astSizeOf.IsArray);
			Expect(70);
			astExpression=astSizeOf; 
			break;
		}
		default: SynErr(113); break;
		}
		while (StartOf(17)) {
			if (la.kind == 58) {
				Get();
				AstPostIncrement astPostIncrement=new AstPostIncrement(this); 
				astPostIncrement.AstExpression=astExpression;
				astExpression=astPostIncrement;
				
			} else if (la.kind == 52) {
				Get();
				AstPostDecrement astPostDecrement=new AstPostDecrement(this); 
				astPostDecrement.AstExpression=astExpression;
				astExpression=astPostDecrement;
				
			} else if (la.kind == 54) {
				Get();
				Expect(1);
				if(astExpression is AstVariableReference){
				AstVariableReference astVariableReference=(AstVariableReference)astExpression;
				astVariableReference.VariableName+="."+t.val;
				astExpression =astVariableReference;										
				}else if(astExpression is AstConstant){
				AstLiteralVarReference astLiteralVarReference =new AstLiteralVarReference(this);
				astLiteralVarReference.AstConstant =(AstConstant)astExpression;
				astLiteralVarReference.VariableName = t.val;
				astExpression = astLiteralVarReference;										
				}else if(astExpression is AstLiteralVarReference){
				AstLiteralVarReference astLiteralVarReference=(AstLiteralVarReference)astExpression;
				astLiteralVarReference.VariableName+="."+t.val;
				astExpression=astLiteralVarReference;
				}else if(astExpression is AstMemberReference){
				AstMemberReference astMemberReference=(AstMemberReference)astExpression;
				astMemberReference.Type+="."+t.val;
				astExpression =astMemberReference;
				}
				
				
			} else if (la.kind == 61) {
				Get();
				AstMethodCall astMethodCall=new AstMethodCall(this,false); 
				if(astExpression is AstVariableReference)
				astMethodCall.Name=((AstVariableReference)astExpression).VariableName; 
				if (StartOf(12)) {
					AstArgument astArgument1=null;
					Argument(out astArgument1);
					astMethodCall.ArgumentCollection.Add(astArgument1);
					while (la.kind == 51) {
						AstArgument astArgument2=null; 
						Get();
						Argument(out astArgument2);
						astMethodCall.ArgumentCollection.Add(astArgument2);
					}
				}
				astExpression=astMethodCall; 
				Expect(70);
			} else {
				Get();
				AstIndexer astIndexer = new AstIndexer(this);
				Expr(out astIndexer.Expression);
				astExpression=astIndexer; 
				Expect(69);
			}
		}
	}

	void Literal(out IAstExpression astExpression) {
		astExpression=null; 
		switch (la.kind) {
		case 2: {
			Get();
			AstIntegerConstant astIntegerConstant=new AstIntegerConstant(this,false);
			astIntegerConstant.ConstantValue=int.Parse(t.val);  
			astExpression=astIntegerConstant; 
			break;
		}
		case 3: {
			Get();
			AstRealConstant astRealConstant=new AstRealConstant(this,false);
			astRealConstant.ConstantValue=double.Parse(t.val);  
			astExpression = astRealConstant; 
			break;
		}
		case 4: {
			Get();
			AstCharConstant astCharConstant=new AstCharConstant(this,false);
			astCharConstant.ConstantValue=char.Parse(t.val.Replace("'",""));
			astExpression=astCharConstant; 
			break;
		}
		case 5: {
			Get();
			AstStringConstant astStringConstant=new AstStringConstant(this,false);
			astStringConstant.ConstantValue=t.val.Substring(1,t.val.Length-2);  
			astExpression = astStringConstant; 
			break;
		}
		case 42: {
			Get();
			AstBooleanConstant astBooleanConstant=new AstBooleanConstant(this,false);
			astBooleanConstant.ConstantValue=true;  
			astExpression = astBooleanConstant; 
			break;
		}
		case 19: {
			Get();
			AstBooleanConstant astBooleanConstant=new AstBooleanConstant(this,false);
			astBooleanConstant.ConstantValue=false;  
			astExpression = astBooleanConstant; 
			break;
		}
		case 28: {
			Get();
			AstNull astNull=new AstNull(this,false);
			astExpression = astNull; 
			break;
		}
		default: SynErr(114); break;
		}
	}

	void ArrayInit(out AstArrayInitialization astArrayInitialization) {
		astArrayInitialization=new AstArrayInitialization(this,false); 
		Expect(59);
		if (StartOf(12)) {
			IAstExpression astExpression1=null; 
			Expr(out astExpression1);
			astArrayInitialization.AstExpressionCollection.Add(astExpression1); 
			while (la.kind == 51) {
				Get();
				IAstExpression astExpression2=null; 
				Expr(out astExpression2);
				astArrayInitialization.AstExpressionCollection.Add(astExpression2); 
			}
		}
		Expect(68);
	}

	void Par(out AstParameter astParameter) {
		astParameter=new AstParameter(this); 
		astParameter.ParameterType=new AstPassByValueParameterType(this);
		
		if (la.kind == 81) {
			Get();
			astParameter.ParameterType=new AstPassByRefParameterType(this,false); 
		}
		Type(out astParameter.Type,out astParameter.IsArray);
		Expect(1);
		astParameter.Name=t.val; 
	}

	void GetAccessor(ref AstAccessor astAccessor) {
		astAccessor.AstGetAccessor=new AstGetAccessor(this); 
		Expect(1);
		if (la.kind == 59) {
			Block(out astAccessor.AstGetAccessor.AstBlock);
		} else if (la.kind == 71) {
			Get();
		} else SynErr(115);
	}

	void SetAccessor(ref AstAccessor astAccessor) {
		astAccessor.AstSetAccessor=new AstSetAccessor(this); 
		Expect(1);
		if (la.kind == 59) {
			Block(out astAccessor.AstSetAccessor.AstBlock);
		} else if (la.kind == 71) {
			Get();
		} else SynErr(116);
	}



	public void Parse() {
		la = new Token();
		la.val = "";		
		Get();
		LLVMSharp();
		Expect(0);

	}
	
	static readonly bool[,] set = {
		{T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, T,T,T,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,T,x,x, x,x,x,T, x,x,T,T, T,x,x,x, T,T,T,x, T,x,x,T, T,x,x,x, x,T,x,T, T,T,T,x, T,x,T,T, T,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,T,x, T,x,T,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,T,x,x, x,x,x,T, x,x,T,x, x,x,x,x, x,x,x,x, T,x,x,x, T,x,x,x, x,T,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x},
		{x,T,x,x, x,x,x,T, x,x,T,x, x,x,x,x, x,x,x,x, T,x,x,x, T,x,x,x, x,T,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,T, x,x,T,x, x,x,x,x, x,x,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,T,T,T, T,T,T,T, T,x,T,x, T,T,T,x, x,x,x,T, T,T,T,x, T,x,x,T, T,T,T,x, x,x,x,T, x,T,x,T, x,T,T,T, x,x,x,T, x,x,x,T, T,x,x,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, x,x,x,x, x,T,T,T, T,x,x,x},
		{x,T,T,T, T,T,T,T, T,x,T,x, T,T,T,x, x,x,x,T, T,T,T,x, T,x,x,T, T,T,x,x, x,x,x,T, x,T,x,T, x,T,T,T, x,x,x,T, x,x,x,T, T,T,x,T, T,T,T,T, x,T,T,T, T,T,T,T, T,T,T,T, T,x,x,x, x,T,T,T, T,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,T, T,x,x,x, x,x,x,x},
		{x,T,T,T, T,T,T,T, x,x,T,x, x,x,x,x, x,x,x,T, T,x,x,x, T,x,x,T, T,T,x,x, x,x,x,x, x,T,x,T, x,T,T,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,T,x, x,T,x,x, T,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,T,T,T, T,T,T,T, T,x,T,x, T,T,T,x, x,x,x,T, T,T,T,x, T,x,x,T, T,T,x,x, x,x,x,T, x,T,x,T, x,T,T,T, x,x,x,T, x,x,x,x, T,x,x,x, x,x,T,T, x,T,x,x, T,x,T,T, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,T,T,T, T,T,T,T, T,x,T,x, x,T,T,x, x,x,x,T, T,T,T,x, T,x,x,T, T,T,x,x, x,x,x,T, x,T,x,T, x,T,T,T, x,x,x,T, x,x,x,x, T,x,x,x, x,x,T,T, x,T,x,x, T,x,T,T, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,x,x, x,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,x,x, x,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,x, x,x,T,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x}

	};

    #region IParser Members

    public IToken Token
    {
        [DebuggerStepThrough]
        get { return t; }
    }

    public IToken LookAhead
    {
        [DebuggerStepThrough]
        get { return la; }
    }

    public IScanner Scanner
    {
        [DebuggerStepThrough]
        get { return scanner; }
    }

    #endregion
} // end Parser



public class Errors {
	public int count = 0;                                    // number of errors detected
   
    // Use this to store list of errors instead of just writing to the textwriter.
    public ErrorList errorList = new ErrorList();
     
	public void SynErr (int line, int col, int n, string fileName) {
		string s;
		switch (n) {
			case 0: s = "EOF expected"; break;
			case 1: s = "ident expected"; break;
			case 2: s = "integerConstant expected"; break;
			case 3: s = "realConstant expected"; break;
			case 4: s = "characterConstant expected"; break;
			case 5: s = "stringConstant expected"; break;
			case 6: s = "base expected"; break;
			case 7: s = "bool expected"; break;
			case 8: s = "break expected"; break;
			case 9: s = "case expected"; break;
			case 10: s = "char expected"; break;
			case 11: s = "class expected"; break;
			case 12: s = "const expected"; break;
			case 13: s = "continue expected"; break;
			case 14: s = "do expected"; break;
			case 15: s = "else expected"; break;
			case 16: s = "enum expected"; break;
			case 17: s = "explicit expected"; break;
			case 18: s = "extern expected"; break;
			case 19: s = "false expected"; break;
			case 20: s = "float expected"; break;
			case 21: s = "for expected"; break;
			case 22: s = "if expected"; break;
			case 23: s = "implicit expected"; break;
			case 24: s = "int expected"; break;
			case 25: s = "internal expected"; break;
			case 26: s = "namespace expected"; break;
			case 27: s = "new expected"; break;
			case 28: s = "null expected"; break;
			case 29: s = "object expected"; break;
			case 30: s = "operator expected"; break;
			case 31: s = "override expected"; break;
			case 32: s = "private expected"; break;
			case 33: s = "protected expected"; break;
			case 34: s = "public expected"; break;
			case 35: s = "return expected"; break;
			case 36: s = "sealed expected"; break;
			case 37: s = "sizeof expected"; break;
			case 38: s = "static expected"; break;
			case 39: s = "string expected"; break;
			case 40: s = "struct expected"; break;
			case 41: s = "this expected"; break;
			case 42: s = "true expected"; break;
			case 43: s = "typeof expected"; break;
			case 44: s = "usingKW expected"; break;
			case 45: s = "virtual expected"; break;
			case 46: s = "void expected"; break;
			case 47: s = "while expected"; break;
			case 48: s = "and expected"; break;
			case 49: s = "assignment expected"; break;
			case 50: s = "colon expected"; break;
			case 51: s = "comma expected"; break;
			case 52: s = "decrement expected"; break;
			case 53: s = "divide expected"; break;
			case 54: s = "dot expected"; break;
			case 55: s = "conditionalequality expected"; break;
			case 56: s = "greater expected"; break;
			case 57: s = "greaterorequals expected"; break;
			case 58: s = "increment expected"; break;
			case 59: s = "leftbrace expected"; break;
			case 60: s = "leftbrack expected"; break;
			case 61: s = "leftpar expected"; break;
			case 62: s = "lessthan expected"; break;
			case 63: s = "lessoreqals expected"; break;
			case 64: s = "minus expected"; break;
			case 65: s = "notequals expected"; break;
			case 66: s = "not expected"; break;
			case 67: s = "plus expected"; break;
			case 68: s = "rightbrace expected"; break;
			case 69: s = "rightbrack expected"; break;
			case 70: s = "rightpar expected"; break;
			case 71: s = "semicolon expected"; break;
			case 72: s = "times expected"; break;
			case 73: s = "\"+=\" expected"; break;
			case 74: s = "\"-=\" expected"; break;
			case 75: s = "\"*=\" expected"; break;
			case 76: s = "\"/=\" expected"; break;
			case 77: s = "\"||\" expected"; break;
			case 78: s = "\"&&\" expected"; break;
			case 79: s = "\"is\" expected"; break;
			case 80: s = "\"as\" expected"; break;
			case 81: s = "\"ref\" expected"; break;
			case 82: s = "??? expected"; break;
			case 83: s = "invalid NamespaceMember"; break;
			case 84: s = "invalid TypeModifiers"; break;
			case 85: s = "invalid TypeDecl"; break;
			case 86: s = "invalid ClassType"; break;
			case 87: s = "invalid MemberModifier"; break;
			case 88: s = "invalid StructMember"; break;
			case 89: s = "invalid StructMember"; break;
			case 90: s = "invalid StructMember"; break;
			case 91: s = "invalid StructMember"; break;
			case 92: s = "invalid StructMember"; break;
			case 93: s = "invalid StructMember"; break;
			case 94: s = "invalid StructMember"; break;
			case 95: s = "invalid StructMember"; break;
			case 96: s = "invalid Type"; break;
			case 97: s = "invalid Type"; break;
			case 98: s = "invalid Expr"; break;
			case 99: s = "invalid ConstructorCall"; break;
			case 100: s = "invalid OverloadableOp"; break;
			case 101: s = "invalid Accessors"; break;
			case 102: s = "invalid IntType"; break;
			case 103: s = "invalid SimpleType"; break;
			case 104: s = "invalid Statement"; break;
			case 105: s = "invalid EmbeddedStatement"; break;
			case 106: s = "invalid Init"; break;
			case 107: s = "invalid StatementExpr"; break;
			case 108: s = "invalid ForInit"; break;
			case 109: s = "invalid Unary"; break;
			case 110: s = "invalid AssignOp"; break;
			case 111: s = "invalid Primary"; break;
			case 112: s = "invalid Primary"; break;
			case 113: s = "invalid Primary"; break;
			case 114: s = "invalid Literal"; break;
			case 115: s = "invalid GetAccessor"; break;
			case 116: s = "invalid SetAccessor"; break;

			default: s = "error " + n; break;
		}
		errorList.Add(new ErrorInfo(ErrorType.SyntaxError, s ,line , col, fileName));
		count++;
	}

	public void SemErr (int line, int col, string s) {
		errorList.Add(new ErrorInfo(ErrorType.SymenticError, s ,line , col));
		count++;
	}

	public void SemErr (int line, int col, string s,string fileName) {
		errorList.Add(new ErrorInfo(ErrorType.SymenticError, s ,line , col, fileName));
		count++;
	}
	
	public void SemErr (string s) {
		//todo
		//errorStream.WriteLine(s);
		count++;
	}
	
	public void Warning (int line, int col, string s) {
		errorList.Add(new ErrorInfo(ErrorType.Warning, s ,line , col));
	}

	public void Warning (int line, int col, string s,string fileName) {
		errorList.Add(new ErrorInfo(ErrorType.Warning, s ,line , col, fileName));
	}
	
	public void Warning(string s) {
	    //todo
		//errorStream.WriteLine(s);
	}
} // Errors


public class FatalError: Exception {
	public FatalError(string m): base(m) {}
}

public enum ErrorType{
    SyntaxError,
    SymenticError,
    Warning
}

public class ErrorInfo{

    public ErrorType type;
    public string message;
    public int line;
    public int col;
	public string fileName;
    
    public ErrorInfo(){}
    
    public ErrorInfo(ErrorType type,string message,int line,int col){
        this.type=type;
        this.message=message;
        this.line=line;
        this.col=col;
    }
    
	public ErrorInfo(ErrorType type,string message,int line,int col,string fileName)
		: this(type,message,line,col)
	{
		this.fileName=fileName;
	}
}

public delegate void ErrorHandler(object o, ErrorArgs e);

public class ErrorArgs: EventArgs{
    public readonly ErrorInfo errorInfo;
    public ErrorArgs(ErrorInfo errorInfo){
        this.errorInfo = errorInfo;
    }
}

public class ErrorList : System.Collections.ArrayList
{
    public override int Add(object value)
    {
        if(!(value is ErrorInfo))
            throw new FatalError("value added to errorlist must be of type ErrorInfo.");
        int rt = base.Add(value);
        if(ErrorAdded!=null)
            ErrorAdded(this,new ErrorArgs((ErrorInfo)value));
        return rt;
    }

    public event ErrorHandler ErrorAdded;
    
    public ErrorList() { }
}